(* ::Package:: *)

(* Autogenerated Package *)

(* ::Text:: *)
(*
	This implements all of the functionality used to build the H5+ spectrum
*)



BeginPackage["SpectrumScriptPackage`", {"H5Core`"}];


loadEnvironment::usage="";


(* ::Subsubsubsection::Closed:: *)
(*Caching / Debugging*)



dumpSymbolFile::usage="";
dumpSymbol::usage="";
cachedLoad::usage="";
debugPrint::usage="";


(* ::Subsubsubsection::Closed:: *)
(*r1/r2*)



getR1R2Potential::usage="";
getR1R2PotentialMin::usage="";
getR1R2Wavefunctions::usage="";


(* ::Subsubsubsection::Closed:: *)
(*Phases*)



meanShiftedWavefunctions::usage="";


rephaseThingies::usage="";
rephaseWfns::usage="";
getPhaseCorrection::usage="";
getCoeffPhaseCorrection::usage="";
getVectorPhaseCorrection::usage="";


smoothOutCoeffs::usage="";


correctRowFlips::usage="";


(* ::Subsubsubsection::Closed:: *)
(*Grids*)



gridMemberQ::usage="";


(* ::Subsubsubsection::Closed:: *)
(*Extrap*)



extrapolatedFunction::usage="";


(* ::Subsubsubsection::Closed:: *)
(*SCF*)



scfGrid::usage="";
scfWavefunction::usage="";
scfCoeffData::usage="";


(* ::Subsubsubsection::Closed:: *)
(*Overlaps*)



getSCFOverlapMatrix::usage="";


smoothOutCoeffs;


(* ::Subsubsubsection::Closed:: *)
(*Wavefunctions*)



coupledKineticEnergy::usage="";
averagedPot::usage="";
coupledPot::usage="";
coupledGrid::usage="";
getWavefunctions::usage="";
pullProjections::usage="";


getPot::usage="";
extrapolatedPotential::usage="";


(* ::Subsubsubsection::Closed:: *)
(*Spectra*)



rebuildInterpolation::usage="";
interpolatedDipoleSurface::usage="";
getDipoleVecs::usage="";
getTransitionMoments::usage="";
getTransitionWavefunctions::usage="";
getIntensities::usage="";
getFreqs::usage="";
buildSpectra::usage="";


lInter::usage="ListInterpolation hack";


Begin["`Private`"];


<<ChemTools`DVR`;
<<ChemTools`Wavefunctions`;
<<ChemTools`DataStructures`;
<<ChemTools`Spectroscopy`;
(* a preload because .mx can do weird things sometimes *)
CoordinateGridObject;
GridFunctionObject;
WavefunctionsObject;


(* ::Subsubsection::Closed:: *)
(*Caching / Loading*)



(* ::Subsubsubsection::Closed:: *)
(*getDumpBase*)



getDumpBase[]:=
  With[{dir=H5PackageFile["results", StringSplit[$Context, "`"][[1]]]},
    Quiet@CreateDirectory[dir];
    dir
    ];


(* ::Subsubsubsection::Closed:: *)
(*dumpSymbolFile*)



dumpSymbolFile[symbol_Symbol]:=
  FileNameJoin@{getDumpBase[], SymbolName[Unevaluated[symbol]]<>".mx"};
dumpSymbolFile~SetAttributes~HoldFirst;


(* ::Subsubsubsection::Closed:: *)
(*dumpSymbol*)



dumpSymbol[symbol_Symbol]:=
  Export[dumpSymbolFile[symbol], symbol];
dumpSymbol~SetAttributes~HoldFirst


(* ::Subsubsubsection::Closed:: *)
(*dumpValue*)



dumpValue[sym_Symbol, val_, unique:True:True]:=
  With[{u=Unique[sym]},
    u=val;
    dumpSymbol[u];
    val
    ];
dumpValue[sym_Symbol, val_, unique:False]:=
  With[{u=sym},
    u=val;
    dumpSymbol[u];
    val
    ]


(* ::Subsubsubsection::Closed:: *)
(*cachedLoad*)



cachedLoad[symbol_Symbol, expr_]:=
  With[{dsf=dumpSymbolFile[symbol]},
    If[FileExistsQ[dsf], 
      symbol=Import[dsf],
      symbol=expr;
      Export[dsf, symbol];
      symbol
      ]
    ];
cachedLoad[expr_]:=
  Function[Null, cachedLoad[#, expr], HoldAllComplete];
cachedLoad~SetAttributes~HoldAllComplete;


(* ::Subsubsubsection::Closed:: *)
(*debugPrint*)



$debugMode=True;
debugPrint[a___]:=
If[$debugMode, Print[a]];


(* ::Subsubsection::Closed:: *)
(*Misc*)



(* ::Subsubsubsection::Closed:: *)
(*gridMemberQ*)



gridMemberQ[pts:_List?(MatrixQ[#, Internal`RealValuedNumberQ]&), range_List, transf_]:=
  Module[
    {
      tpts = transf@pts,
      checker = RegionMember[Cuboid@@Transpose[range]]
      },
    checker/@tpts
    ];
gridMemberQ[pts:_List?(MatrixQ[#, Internal`RealValuedNumberQ]&), range_List]:=
  Module[
    {
      tfunc,
      r2
      },
      Switch[Dimensions[pts][[-1]],
        2,
          tfunc = 
            Transpose[RotationMatrix[-\[Pi]/4].Transpose[#]]&;
          r2 = range[[-2;;]],
        4,
          tfunc = 
            Transpose[ArrayFlatten[{{IdentityMatrix[2], 0}, {0, RotationMatrix[-\[Pi]/4]}}].Transpose[#]]&;
          r2 = range,
        _,
          tfunc = Identity;
          r2 = range
        ];
    gridMemberQ[pts, r2, tfunc]
  ];
gridMemberQ[pts:_List?(VectorQ[#, Internal`RealValuedNumberQ]&), range_List, transf_]:=
  gridMemberQ[{pts}, range, transf][[1]];
gridMemberQ[pts:_List?(VectorQ[#, Internal`RealValuedNumberQ]&), range_List]:=
  gridMemberQ[{pts}, range][[1]];
gridMemberQ[pts_, i_InterpolatingFunction, transf_]:=
  gridMemberQ[pts, i["Domain"], transf];
gridMemberQ[pts_, i_InterpolatingFunction]:=
  gridMemberQ[pts, i["Domain"]]


(* ::Subsubsubsection::Closed:: *)
(*nonlinearFitStuff*)



nonlinearFitStuff[data_, r_, form_, r0_, c_, ops___]:=
  Replace[
    Thread[
      ToExpression[
        "par"<>ToString[#]&/@Range[Length[form["Parameters"]]], 
        StandardForm, 
        Hold
        ],
      Hold
      ],
    Hold[p__]:>
      Block[p,
        With[
          {
            model = 
              form["Form"]/.
                Join[
                  Thread[form["Parameters"]->p],
                  {Point->r0, Value->c}
                  ]
             },
          NonlinearModelFit[
            data,
            model, 
            p, 
            r,
            ops
            ]["Function"]
          ]
        ]
    ]


(* ::Subsubsubsection::Closed:: *)
(*fitExtrapForms*)



fitExtrapForms[
  trueRotSubGrids_,
  pointSampling_, fitForms_, monkeyPatch_, 
  gind1_, gind2_,
  ops___
  ]:=
  Block[
    {
      r, forms, 
      nl = pointSampling[[1]], nr = pointSampling[[2]],
      gl, gr
      },
    forms = Through[fitForms[r]];
    debugPrint["Fitting forms"];
    Map[
      Function[
        gl = (* take the points to fit onthe "left" *)
          #[[
            ;;Min@{Replace[nl, Scaled[i_]:>Floor[i*Length[#]]], Length@#},
            {gind2, 3}
            ]];
        gr = (* take the points to fit onthe "right" *)
          #[[
            -Min@{Replace[nr, Scaled[i_]:>Floor[i*Length[#]]], Length@#};;,
            {gind2, 3}
            ]];
        (*debugPrint["Generating fits..."];*)
        MapThread[
          With[{data = #, r0 = #3[[1]], c = #3[[2]]},
            If[Length[data]===0, 
              Throw["?No data @ ``, ``?"~TemplateApply~{r0, c}]
              ];
            If[ListQ@#2, (* linear fitted model vs non linear model *)
              (*debugPrint["Fitting data points..."];*)
              If[Length@data==1,
                (* single data points are always extrapolated as a constant function *)
                With[{pt=data[[1, -1]]}, ConstantArray[pt, Length[#]]&],
                LinearModelFit[data, #2, r, ops]["Function"]
                ],
              nonlinearFitStuff[data, r, #2, r0, c, ops]
              ]//monkeyPatch[#, r0, c]&
            ]&,
          {
            {gl, gr},
            forms,
            (* take the boundary points *)
            #[[{1, -1}, {gind2, 3}]]
            }
          ]
        ],
      trueRotSubGrids
      ]
    ]


(* ::Subsubsubsection::Closed:: *)
(*extraGridVals*)



extraGridVals[
  rotSubGrids_, trueRotSubGrids_,
  gind1_, gind2_,
  fits_
  ]:=
  MapThread[
    With[
      {
        minFit = #[[1]], maxFit = #[[2]], 
        ptRaw = #3[[All, gind2]],
        goodBounds = MinMax @ #2[[All, gind2]]
        },
      (* use the left-and-right side first to evaluate the smaller and larger points*)
      Join[
        With[
          {
            (* get the points off the grid too small*)
            pts=
              Pick[ptRaw, UnitStep[goodBounds[[1]] - (ptRaw + $MachineEpsilon)], 1]
            },
          (* if there no points don't worry about it *)
          If[Length@pts>0,
            (* recreate the triples we originally had by adding a constant slice coordinate *)
            Transpose[
              {
                ConstantArray[#3[[1, gind1]], Length@pts],
                pts,
                minFit@pts (* actual extrapolation to smaller points *)
                }[[{gind1, gind2, 3}]]
                ],
            pts
           ]
          ],
        #2,
        With[
          {
            (* get the points off the grid too large*)
            pts=
              Pick[ptRaw, (ptRaw - $MachineEpsilon) - goodBounds[[2]]//UnitStep, 1]
            },
          (* if there no points don't worry about it *)
          If[Length@pts>0,
            (* recreate the triples we originally had by adding a constant slice coordinate *)
            Transpose[
              {
                ConstantArray[#3[[1, gind1]], Length@pts],
                pts, 
                maxFit@pts  (* actual extrapolation to larger points *)
                }[[{gind1, gind2, 3}]]
              ],
            pts
            ]
          ]
        ]
      ]&,
    {
      fits,
      trueRotSubGrids,
        KeyTake[rotSubGrids, Keys[trueRotSubGrids]]
      }
    ];


(* ::Subsubsubsection::Closed:: *)
(*extrapFitForms*)



extrapFitForms=
  {
      (* eh fuck this form it's fine to just use a 6-th order polynomial to fit the _entire_ potential *)
      <|
        "Form"->
          {
            C[2] + C[1]*Exp[-C[3]*#], 
            {C[3]>0(*, C[2] + C[1]*Exp[-C[3]*Point] \[Equal] Value*)}
            },
        "Parameters"->Array[C, 3]
        |>&, 
      <|"Form"->(C[2]+C[1]/((#)^4)), "Parameters"->Array[C, 2]|>&
      };


(* ::Subsubsubsection::Closed:: *)
(*extrapolatedFunction*)



extrapolatedFunction//Clear
extrapolatedFunction[
  fn_, 
  cutOffs: {
    Except[_Integer?(0<#<1000&), _?NumericQ], 
    Except[_Integer?(0<#<1000&), _?NumericQ]
    } : {-10^8, 5*10^8} 
    (* "bad values" should be indicated by larger or smaller numbers than this *),
  pointSampling:{_Scaled|_Integer, _Scaled|_Integer}:{Scaled[.1], Scaled[.2]},
  fitForms: {_Function, _Function} : extrapFitForms,
  direction:First|Last:First,
  symmetry:1|-1|None:1,
  def:DefaultValue[_]:DefaultValue[Automatic],
  ops:OptionsPattern[]
  ]:=
  Module[
    {
      trueGridVals = 
        Pick[fn,
          UnitStep[cutOffs[[2]] - fn[[All, 3]]]*
            UnitStep[fn[[All, 3]] - cutOffs[[1]]],
          1
          ],
      basePot,
      rotWfnGrid, trueGridRot,
      trueRotSubGrids, rotSubGrids,
      fits, monkeyPatch,
      gridVals, gpts,
      gptsRegrouped, fullGridRegrouped,
      missing, patchedPts,
      gind1=Replace[direction, {First->1, Last->2}],
      gind2=Replace[direction, {First->2, Last->1}],
      dv=def[[1]]
      },
    debugPrint["Extracting grids"];
    rotWfnGrid = 
      fn[[All, ;;2]]//RotationMatrix[-\[Pi]/4].Transpose[#]&//Transpose;
    trueGridRot = 
      Join[
        trueGridVals[[All, ;;2]]//RotationMatrix[-\[Pi]/4].Transpose[#]&//Transpose, 
        trueGridVals[[All, {3}]], 
        2
        ];
    debugPrint["Rotating to R1/R2 space"];
    rotSubGrids =
      GroupBy[rotWfnGrid, 
        (Round[#[[gind1]], .00001]&)->(#[[;;2]]&), SortBy[#[[gind2]]&]];
    trueRotSubGrids = 
      GroupBy[trueGridRot, (Round[#[[gind1]], .00001]&), SortBy[#[[gind2]]&]];
    monkeyPatch[f_, r_, c_]:=f;
    debugPrint["Fitting forms"];
    fits = (* take the subgrids and extrapolate along them *)
      fitExtrapForms[
        trueRotSubGrids,
        pointSampling, fitForms, 
        monkeyPatch, 
        gind1, gind2,
        ops
        ];
    debugPrint["Extapolating grid values"];
    (* use the fitted forms to extrapolate off the grid *)
    gridVals = 
      extraGridVals[rotSubGrids, trueRotSubGrids, gind1, gind2, fits];
    gpts=
      (* reformat so that we have a list of triples*)
      Flatten[Values[gridVals], 1];
    debugPrint["Symmetrizing grid"];
    If[symmetry=!=None,
      gpts=
        (* symmetrize the grid of triples *)
        Join[
          #,
          Transpose[{#[[All, gind2]], #[[All, gind1]], symmetry*#[[All, 3]]}]
          ]&@gpts
      ];
    gpts=
    DeleteDuplicatesBy[gpts, Round[#[[;;2]], .005]&];
    gpts=
     (* convert back to a/s space *)
     Join[
       RotationMatrix[Pi/4].Transpose[gpts[[All, ;;2]]]//Transpose, 
       gpts[[All, {3}]],
       2
       ];
    (* group extrap points by a value? *)
    gptsRegrouped = GroupBy[gpts, Round[#[[1]], .005]&];
    (* group everything by a value? *)
    fullGridRegrouped = GroupBy[fn[[All, ;;2]], Round[#[[1]], .005]&];
    (*dumpSymbol[gptsRegrouped];*)
    debugPrint["Doing secondary extrapolation"];
    patchedPts=
      MapThread[
        If[Length[#] =!= Length[#2], 
          (* 
                            I guess some times we don't have the full grid? 
                            In this case we just extrapolate using a default value... 
                            (originally default stuff... dunno what should do)
                      *)
         Join[
           #2,
           List/@
             Interpolation[
               #[[All, {2, 3}]], 
               {
                 "ExtrapolationHandler"->{
                   Replace[dv, n_?NumberQ:>(n&)], 
                   "WarningMessage"->False
                   }
                 }
               ][#2[[All, 2]]],
             2
             ],
          #
          ]&,
       {
         KeySort@gptsRegrouped,
         KeySort@fullGridRegrouped
         }
       ];
     Round[
       Developer`ToPackedArray@
         DeleteDuplicatesBy[
           Flatten[Values[patchedPts], 1],
           Round[#[[;;2]], .005]&
           ],
       .0001
       ](*//Interpolation*)
    ];
extrapolatedFunction[
  a__,
  "Both",
  symmetry:1|-1|None:1,
  def:DefaultValue[_]:DefaultValue[Automatic],
  ops:OptionsPattern[]
  ]:=
  Module[{dv = 10.^9.5+2*Abs[Replace[def[[1]], Automatic:>5000]], d1, d2, d3, d},
    d1 = extrapolatedFunction[a, First, None, DefaultValue[dv], ops];
    d2 = extrapolatedFunction[a, Last, symmetry, def, ops];
    d = DeleteDuplicatesBy[
      Join[Pick[d1, UnitStep[(dv-10)-d1[[All, 3]]], 1], d2], Round[#[[;;2]], .001]&
      ]
    ]


(* ::Subsubsubsection::Closed:: *)
(*lInter*)



lInter[grid_, ops___]:=
  Module[
    {gtot},
    gtot =
      SortBy[
        SortBy[#[[2]]&]/@
          GatherBy[grid, {Round[#[[1]], .01]&}], 
        #[[1, 1]]&
        ];
    ListInterpolation[
      gtot[[All, All, 3]],
      CoordinateBounds[gtot][[;;2]],
      ops
      ]
    ]
    


(* ::Subsubsection::Closed:: *)
(*R1R2 Stuff*)



(* ::Subsubsubsection::Closed:: *)
(*getR1R2Potential*)



getR1R2Potential[fullPot_, {a_, s_}]:=
  If[
    With[
      {
        R1R2=RotationMatrix[-\[Pi]/4].{a, s}, 
        bounds=$H5PotentialRegion[[3]](*fullPot[[1, 3]]*)
        },
      AllTrue[R1R2, bounds[[1]]<=#<bounds[[2]]&]
      ],
    H5VectorizedInterpCut[
      {a, s, Automatic, Automatic}, 
      fullPot, 
      $H5PotentialRegion,
      10.^9, 
      0.
      ],
    $Failed
    ];


(* ::Subsubsubsection::Closed:: *)
(*getR1R2PotentialMin*)



getR1R2PotentialMin[shit_:None, potGenerator_, r1r2grid_, saGrid_]:=
  AssociationMap[
    With[{pot=potGenerator[#]},
      If[pot=!=$Failed,
        Min[pot@r1r2grid["Points"]],
        $Failed
        ]
      ]&,
    saGrid@"Points"
    ]


(* ::Subsubsubsection::Closed:: *)
(*getR1R2Wavefunctions*)



getR1R2Wavefunctions[dvr_, potGenerator_, r1r2grid_, saGrid_]:=
  AssociationMap[
    With[{pot=potGenerator[#]},
      If[pot=!=$Failed,
        dvr[
          "Wavefunctions",
          "PotentialEnergy"->
              SparseArray[Band[{1, 1}]->pot@r1r2grid["Points"]],
          "Grid"->r1r2grid,
          "ArnoldiIterations"->5000,
          "NodelessGroundState"->True
          ],
        $Failed
        ]
      ]&,
    saGrid@"Points"
    ]


(* ::Subsubsection::Closed:: *)
(*Phase Corrections*)



(* ::Subsubsubsection::Closed:: *)
(*meanShiftedWavefunctions*)



shiftWfGrid[nearest_,baseGrid_, vals_]:=
  With[{mean=nearest[Mean[WeightedData[baseGrid, Abs@vals]]][[1]]},
    Transpose[baseGrid]-mean//Transpose
    ];
meanShiftedWavefunctions[wfns_WavefunctionsObject]:=
  Module[
    {
      baseGrid,
      nfunc,
      shifts,
      newGrids,
      gridBits,
      zeroGrid,
      fullGrid,
      newWfns,
      newWfns2,
      newWfnsGrid,
      grids
      },
    baseGrid=Flatten[Normal[wfns@"Grid"], 1];
    nfunc=Nearest[baseGrid];
    (* shift the original grids *)
    debugPrint["Shifting core grids"];
    newGrids = 
      Map[
        Join[
          shiftWfGrid[nfunc, baseGrid, Flatten@#["Values"]],
          List/@Flatten[#["Values"]],
          2
          ]&,
        wfns["Wavefunctions"]
        ];
    (*dumpSymbol[newGrids];*)
    (* determine what the tensor product grid parts would be *)
    gridBits=
      Sort@*DeleteDuplicatesBy[Round[#, 10.^-3]&]@*Flatten/@{
        newGrids[[All, All, 1]],
        newGrids[[All, All, 2]]
        };
    (* make the full grid that every wavefunction will live on *)
    debugPrint["Constructing full grid"];
    fullGrid=Tuples[gridBits];
    (* but zero out undefined parts *)
    zeroGrid=Join[fullGrid, ConstantArray[0., {Length@fullGrid, 1}], 2];
    debugPrint["Reconstructing wavefunctions"];
    newWfns=(* fill out the entire grid *)
      DeleteDuplicatesBy[
        Join[#, zeroGrid], 
        Round[#[[;;2]], 10.^-3]&
        ]&/@newGrids;
    (*dumpSymbol[newWfns];*)
    (* set up the new wavefunctions *)
    newWfns = #[[Ordering[Round[#[[All, ;;2]], 10.^-2]]]]&/@newWfns;
    (*newWfns2 = newWfns;*)
    (*dumpSymbol[newWfns2];*)
    grids = DeleteDuplicates@Map[Sort, Round[newWfns[[All, All, ;;2]], 10.^-2]];
    If[Length@grids>1, 
      debugPrint["`` distinct grids"~TemplateApply~Length[grids]];
      dumpSymbol[grids]
      ];
    debugPrint["Making grid functions"];
    newWfnsGrid=(* by making a new full coordinate grid *)
      CoordinateGridObject@
        Partition[newWfns[[1, All, ;;2]], Length@gridBits[[1]]];
    debugPrint@
      TemplateApply[
        "`` wavefunctions with length `` and grid of dimension ``",
        {
          Length@newWfns,
          DeleteDuplicates[Length/@newWfns],
          Dimensions[newWfnsGrid]
          }
        ];
    newWfns = 
      GridFunctionObject[newWfnsGrid, #[[All, 3]]]&/@newWfns;
    (* and then finally constructing a new WavefunctionsObject *)
    debugPrint["Making wavefunction object"];
    WavefunctionsObject[
      {
        wfns["Energies"],
        newWfns
        },
      newWfnsGrid
      ]
    ];
meanShiftedWavefunctions[wfList_]:=
  Module[
    {
      nonFailedPos=Pick[Range[Length@wfList], #=!=$Failed&/@wfList],
      nonFailedWfns,
      shifted,
      flatWfList = Flatten[wfList],
      newWfnsList
      },
    debugPrint["Mean shifting wavefunctions"];
    nonFailedWfns = 
      WavefunctionsObject[
        {
          ConstantArray[0, Length@nonFailedPos],
          flatWfList[[nonFailedPos]]
          },
        flatWfList[[nonFailedPos[[1]]]]@"Grid"
        ];
    shifted = meanShiftedWavefunctions[nonFailedWfns];
    debugPrint["Reconstructing wavefunction list"];
    newWfnsList = ConstantArray[$Failed, Length@wfList];
    newWfnsList[[nonFailedPos]] = 
      WavefunctionsObject[{{0}, {#}}, #["Grid"]]&/@shifted["Wavefunctions"];
    newWfnsList
    ];


(* ::Subsubsubsection::Closed:: *)
(*rephaseThingies*)



rephaseThingies=
  Compile[{{overlaps, _Real, 1}, {init, _Integer}, {tol, _Real}},
    Module[{prev, el, ov=overlaps,swapEl=init},
      Prepend[
        Table[
          (* 
				  if the previous one had to be flipped and the next one and it have the same sign the next one
				  should also be flipped, I think...
				  *)
          el=ov[[i]];
          If[el<-tol, swapEl=-swapEl];
          swapEl,
          {i, Length@ov}
          ],
        init
        ]
      ](*,
		CompilationTarget\[Rule]"C"*)
    ];


(* ::Subsubsubsection::Closed:: *)
(*rephaseWfns*)



rephaseWfns[s_, wfns_]:=
  WavefunctionsObject[
    {
      wfns["Energies"], 
      Map[Scale[#, s]&, wfns["Wavefunctions"]]
      },
    wfns["Grid"]
    ]


(* ::Subsubsubsection::Closed:: *)
(*generalizedPhaseCorrection*)



generalizedPhaseCorrection//Clear
generalizedPhaseCorrection[
 {data_, validTest_, prep_, metric_},
  grid_,
  basePhase:1|-1:1,
  defaultOrder:First|Last:First,
  tol:_?(NumericQ[#]&&(!IntegerQ[#]||#==0)&):0.
  ]:=
  Module[
    {
      pos,
      gridPoints=grid["Points"],
      cleanGrid,
      cleanGridSorted,
      gridReordering,
      gridPositions,
      reorderedWfs,
      rephasedWavefunctions,
      fullData,
      overlaps,
      phases,
      orderComplement,
      phaseVector,
      reorderedData,
      rephasingData
      },
    pos=Pick[Range[Length[data]], validTest/@data];
    cleanGrid=Round[grid[[pos]].RotationMatrix[\[Pi]/4], .001];
    rephasingData=
      Table[
        cleanGridSorted=
          MapIndexed[If[EvenQ[#2[[1]]], Reverse, Identity]@#&]@
            SortBy[
              SortBy[#, sorting[[1]]]&/@GatherBy[cleanGrid, -#[[sorting[[2]]]]&], 
              -#[[1, -1]]&
              ];
        gridReordering=
          Flatten@
            Lookup[PositionIndex[cleanGrid], Flatten[cleanGridSorted, 1]];
        gridPositions=pos[[gridReordering]];
        reorderedData=data[[gridPositions]];
        fullData=
          prep[reorderedData, 
            <|
            "GridReordering"->gridReordering,
            "GridPositions"->gridPositions,
            "GridPoints"->grid[[gridPositions]]
            |>
            ];
        overlaps=
          Developer`ToPackedArray[
            metric[
              fullData,
              <|
                "ValidData"->pos,
              "GridReordering"->gridReordering,
              "GridPositions"->gridPositions,
              "GridPoints"->grid[[gridPositions]]
              |>
            ]
          ];
        phases=rephaseThingies[Normal@Diagonal[overlaps, 1], basePhase, tol];
        orderComplement=Complement[Range[Length@data], gridPositions];
        phaseVector=
          Join[phases, ConstantArray[$Failed, Length@orderComplement]][[
            Ordering@Join[gridPositions, orderComplement]
            ]];
        {
          gridReordering,
          phaseVector
          },
        {sorting, {If[defaultOrder===First, {Last, 1}, {First, 2}]}}
        ][[1]];
    {
      gridReordering,
      phaseVector
      } = rephasingData;
    (*If[rephasingData[[1, 2]] =!= rephasingData[[2, 2]],
			Print["Rephasing disagreement by sampling direction. Be careful."]
			];
		{
			gridReordering,
			phaseVector
			} = 
			If[defaultOrder===First,
				rephasingData[[2]],
				rephasingData[[1]]
				];*)
    <|
      "PhaseVector"->phaseVector,
      "Positions"->pos,
      "Ordering"->gridPositions,
      "Phases"->phases
      |>
    ];


(* ::Subsubsubsection::Closed:: *)
(*getPhaseCorrection*)



(* ::Subsubsubsubsection::Closed:: *)
(*prepPCWfns*)



prepPCWfns[state_][reorderedWfs_, ___]:=
  WavefunctionsObject[
    Flatten/@
      Transpose[
        {#["Energies"], #["Wavefunctions"][[state]]}&/@
        reorderedWfs
        ],
     reorderedWfs[[1]]["Grid"]
     ];


(* ::Subsubsubsubsection::Closed:: *)
(*getPhaseCorrection*)



getPhaseCorrection//Clear
getPhaseCorrection[wfs_List, 
  grid_,
  state:{_Integer?IntegerQ}:{2},
  basePhase:1|-1:1,
  rephase:True|False:False,
  defaultOrder:First|Last:First,
  meanShift:"Shift"[True]|"Shift"[False]:"Shift"[True],
  tol:_?(NumericQ[#]&&(!IntegerQ[#]||#==0)&):0.
  ]:=
  Module[
    {
      pc,
      mc,
      newWfns,
      ms = meanShift[[1]]
      },
    mc = 
      If[ms,
        meanShiftedWavefunctions[
          If[#===$Failed, #, #["Wavefunctions"][[state]]]&/@wfs
          ],
        If[#===$Failed, #, #[[state]]]&/@wfs
        ];
    pc = 
      generalizedPhaseCorrection[
        {mc, MatchQ[_WavefunctionsObject], prepPCWfns[state], #@"Overlaps"[#]&},
        grid,
        basePhase,
        defaultOrder,
        tol
        ];
    If[rephase,
      newWfns=
        MapThread[
          If[#===$Failed, #, rephaseWfns[#, #2]]&,
          {pc["PhaseVector"], wfs}
          ],
      newWfns=None
      ];
    Prepend[pc, "Wavefunctions"->newWfns]
    ];


(* ::Subsubsubsubsection::Closed:: *)
(*getPhaseCorrection*)



getPhaseCorrection[
  wfs_List, 
  grid_,
  states:{_Integer?IntegerQ, __Integer?IntegerQ},
  basePhases:1|-1|{(1|-1)..}:1,
  rephase:True|False:True,
  meanShift:"Shift"[True]|"Shift"[False]:"Shift"[True],
  tol:_?(NumericQ[#]&&(!IntegerQ[#]||#==0)&):0.
  ]:=
  Module[{wfSets, rephasing, newWfns},
    wfSets=
      Table[
        If[#===$Failed, #, #[[{state}]]]&/@wfs, 
        {state, states}
        ];
    rephasing=
      MapThread[
        getPhaseCorrection[#, grid, {1}, #2, False, meanShift, tol]&, 
        {
          wfSets,
          Flatten[ConstantArray[basePhases, Length@wfSets]][[;;Length@wfSets]]
          } 
        ];
   (*dumpSymbol[rephasing];
	 dumpSymbol[meanShiftedWfSets];*)
    If[rephase,
      newWfns=
        MapThread[
          If[#===$Failed, #, Join[##]]&,
          MapThread[
            MapThread[
              If[#===$Failed, #, rephaseWfns[#, #2]]&,
              {#["PhaseVector"], #2}
              ]&,
            {rephasing, wfSets}
            ]
          ],
      newWfns=None
      ];
    <|
      "Wavefunctions"->newWfns,
      "Rephasings"->rephasing
      |>
    ]


(* ::Subsubsubsection::Closed:: *)
(*getCoeffPhaseCorrection*)



(* ::Subsubsubsubsection::Closed:: *)
(*prepCoeffRephasing*)



prepCoeffRephasing[dvrWavefunctions_, states_][blerp_, params_]:=
  Module[
    {
      nstates, fleng, pickSpec, pickComp,
      gg, blerpDVR, 
      baseWfnsSCF, baseWfnsDVR, 
      coeffs, coeffLists, grid
      },
    pickSpec = params["GridPositions"];
    blerpDVR=dvrWavefunctions[[pickSpec]];
    baseWfnsSCF=Table[Join@@Map[#[[{m}]]&, blerp], {m, states}];
    baseWfnsDVR=Join@@blerpDVR;
    {baseWfnsSCF, baseWfnsDVR}
    ]


(* ::Subsubsubsubsection::Closed:: *)
(*computePairwiseOverlaps*)



computePairwiseOverlaps[{baseWfnsSCF_, dvrWfs_}, params___]:=
  Module[{coeffs},
    coeffs=
      Transpose@
        Table[
          Developer`ToPackedArray[Diagonal[dvrWfs@"Overlaps"[scfWfs]]],
          {scfWfs, baseWfnsSCF}
          ];
    coeffs.Transpose[coeffs]
    ]


(* ::Subsubsubsubsection::Closed:: *)
(*getCoeffPhaseCorrection*)



getCoeffPhaseCorrection//Clear
getCoeffPhaseCorrection[
  scfWavefunctions_, dvrWavefunctions_, 
  grid_,
  states:{_Integer?IntegerQ, __Integer?IntegerQ},
  basePhases:1|-1|{(1|-1)..}:1,
  rephase:True|False:True,
  tol:_?(NumericQ[#]&&(!IntegerQ[#]||#==0)&):0.
  ]:=
  Module[
    {
      dvrs, scfs,
      rephasing, newWfns
      },
    scfs = scfWavefunctions;
    dvrs = 
      Table[
        If[#===$Failed, #, #[[{state}]]]&/@dvrWavefunctions,
        {state, states}
        ];
    rephasing=
      MapThread[
        With[{u2=Unique[phaseCorrectionVector]},
          u2 = generalizedPhaseCorrection[
            {
              scfs, 
              #=!=$Failed&, 
              prepCoeffRephasing[#, states], 
              With[{u=Unique[pairwiseOverlaps]},
                u = computePairwiseOverlaps[##];
                dumpSymbol[u];
                u
                ]&
              },
            grid,
            #2,
            tol
            ];
          dumpSymbol[u2];
          u2
          ]&,
        {
          dvrs,
          Flatten[ConstantArray[basePhases, Length@dvrs]][[;;Length@dvrs]]
          }
        ];
    If[rephase,
      newWfns=
        MapThread[
          If[#===$Failed, #, Join[##]]&,
          MapThread[
            MapThread[
              If[#===$Failed, #, rephaseWfns[#, #2]]&,
              {#["PhaseVector"], #2}
              ]&,
            {rephasing, dvrs}
            ]
          ],
      newWfns=None
      ];
    <|
      "Wavefunctions"->newWfns,
      "Rephasings"->rephasing
      |>
    ]


(* ::Subsubsubsubsection::Closed:: *)
(*getCoeffForcedPhaseCorrection*)



(* ::Text:: *)
(*An idea worth pursuing eventually, but not just yet...*)



(*getCoeffPhaseCorrection//Clear
getCoeffPhaseCorrection[
	scfWavefunctions_, dvrWavefunctions_, 
	grid_,
	states:{_Integer?IntegerQ, __Integer?IntegerQ},
	knownPhases:{{(1|-1), (1|-1)}..},
	rephase:True|False:True,
	tol:_?(NumericQ[#]&&(!IntegerQ[#]||#\[Equal]0)&):0.
	]:=
	Module[
	  {
	    dvrs, scfs,
	    rephasing, newWfns
	    },
	  scfs = scfWavefunctions;
	  dvrs = 
	    Table[
	      If[#===$Failed, #, #[[{state}]]]&/@dvrWavefunctions,
	      {state, states}
	      ];
		rephasing=
		  Map[
		    generalizedPhaseCorrection[
         {
      		  scfs, 
      		  #=!=$Failed&, 
      		  prepCoeffRephasing[#, states]
      		  },
    		  grid,
    		  #2,
    		  tol
    		  ]&,
  		  {
    		  dvrs
    		  }
    		];
		If[rephase,
			newWfns=
				MapThread[
					If[#===$Failed, #, Join[##]]&,
					MapThread[
						MapThread[
							If[#===$Failed, #, rephaseWfns[#, #2]]&,
							{#["PhaseVector"], #2}
							]&,
						{rephasing, dvrs}
						]
					],
			newWfns=None
			];
		<|
			"Wavefunctions"->newWfns,
			"Rephasings"->rephasing
			|>
		]*)


(* ::Subsubsubsection::Closed:: *)
(*correctRowFlips*)



rowsFlipped[{row1_, row2_}]:=
  Module[
    {
      
      r1, r2,
      r12Len,
      flipCounts,
      mr1, mr2, mr12
      },
    r1 = Select[row1, #!=0&];
    r2 = Select[row2, #!=0&];
    r12Len = Min[Length/@{r1, r2}];
    mr1 = Ceiling[Length[r1]/2];
    mr2 = Ceiling[Length[r2]/2];
    mr12= Floor[r12Len/2];
    r1 = Sign @ r1[[1+mr1-mr12;;mr1+mr12]];
    r2 = Sign @ r2[[1+mr2-mr12;;mr2+mr12]];
    If[Count[r1*r2, -1]>mr12/4, -1, 1]
    ];


correctRowFlips[gridVals_, direction:First|Last:Last, basePhase:1|-1:1]:=
  Module[
    {
      regridded, grouped, 
      gind1 = Replace[direction, {First->1, Last->2}],
      gind2 = Replace[direction, {First->2, Last->1}],
      flippedVec,
      rows,
      rephased,
      recoorded,
      gpsOrig
      },
    regridded = 
      Join[gridVals[[All, ;;2]].RotationMatrix[\[Pi]/4], gridVals[[All, {3}]], 2];
    grouped = 
      KeySort@GroupBy[regridded, (Round[#[[gind1]], .01]&)->(#[[{gind1, gind2, 3}]]&), Sort];
    rows = Values[grouped][[All, All, 3]];
    grouped;
    flippedVec = Table[rowsFlipped[rows[[{i, i+1}]]], {i, Length[rows]-1}];
    rephased=
      rephaseThingies[flippedVec, basePhase, 0]*rows;
    gpsOrig=
      MapThread[
        Transpose[
          {#, #2}[[{gind1, gind2}]]
          ].RotationMatrix[-\[Pi]/4]&,
        {
          Values[grouped][[All, All, 1]],
          Values[grouped][[All, All, 2]]
          }
        ];
       
    recoorded=
      Join@@
        MapThread[
          Join[#, List/@#2, 2]&,
          {
            gpsOrig,
            rephased
            }
          ];
   (*dumpSymbol[recoorded];*)
    Sort[recoorded]
    ]


(* ::Subsubsubsection::Closed:: *)
(*getVectorPhaseCorrection*)



getVectorPhaseCorrection//Clear
getVectorPhaseCorrection[values_List, 
  grid_, 
  basePhase:1|-1:1,
  rephase:True|False:True,
  tol:_Real:.001
  ]:=
  Module[
    {
      pos,
      gridPoints=grid["Points"],
      cleanGrid,
      cleanGridSorted,
      gridReordering,
      gridPositions,
      ratios,
      reorderedVals,
      phases,
      orderComplement,
      phaseVector,
      newValues
      },
    pos=Flatten@Position[values, _?NumericQ, {1}];
    cleanGrid=Round[grid[[pos]].RotationMatrix[\[Pi]/4], .001];
    cleanGridSorted=
      MapIndexed[If[EvenQ[#2[[1]]], Reverse, Identity]@#&]@
        SortBy[
          SortBy[#, First]&/@GatherBy[cleanGrid, -#[[-1]]&], 
          -#[[1, -1]]&
          ];
    gridReordering=
      Flatten@
        Lookup[PositionIndex[cleanGrid], Flatten[cleanGridSorted, 1]
          ];
    gridPositions=pos[[gridReordering]];
    reorderedVals=values[[gridPositions]];
    ratios=MovingMap[If[#[[2]]!=0, Divide@@#, 0.]&, reorderedVals(*Differences[reorderedVals]*), 1];
    (*AppendTo[ratios, ratios[[-1]]]; *)
    phases=rephaseThingies[ratios, basePhase, tol];
    orderComplement=Complement[Range[Length@values], gridPositions];
    phaseVector=
      Join[phases, ConstantArray[$Failed, Length@orderComplement]][[
        Ordering@Join[gridPositions, orderComplement]
        ]];
    If[rephase,
      newValues=
        values*Replace[phaseVector, $Failed->1, 1],
      newValues=None
      ];
    <|
      "Values"->newValues,
      "PhaseVector"->phaseVector,
      "Positions"->pos,
      "Ordering"->gridPositions,
      "Phases"->phases
      |>
    ]


(* ::Subsubsection::Closed:: *)
(*SCF*)



(* ::Subsubsubsection::Closed:: *)
(*scfGrid*)



scfGrid[scfDvr_, basisSize_]:=
  scfGrid[scfDvr, basisSize]=
    scfDvr["Grid",
      "Points"->{basisSize, basisSize},
      "PotentialOptimize"->False
      ];


(* ::Subsubsubsection::Closed:: *)
(*scfWavefunction*)



scfWavefunction//Clear
scfWavefunction[
  scf1DDVR_,
  scfGrid_,
  pot_CompiledFunction,
  states:{{_Integer, _Integer}..},
  n:_Integer|Automatic:Automatic
  ]:=
  WavefunctionsObject[
    "SCF",
    scf1DDVR,
    GridFunctionObject[
      scfGrid,
      pot@scfGrid["Points"]
      ],
    "StateVectors"->states,
    "MaxIterations"->n
    ];


scfWavefunction[
  scf1DDVR_,
  scfGrid_,
  potentialGenerator_,
  {a_, s_},
  states:{{_Integer, _Integer}..},
  n:_Integer|Automatic:Automatic
  ]:=
  Module[{pot=potentialGenerator[{a, s}]},
    If[pot===$Failed,
      $Failed,
      scfWavefunction[
        scf1DDVR,
        scfGrid,
        pot,
        states,
        n
        ]
      ]
    ];


(* ::Subsubsubsection::Closed:: *)
(*scfCoeffData*)



scfCoeffData//Clear
scfCoeffData[
  scf1DDVR_,
  scf2DDVR_,
  scfGrid_,
  potentialGenerator_,
  states_,
  {a_, s_},
  basisSize_
  ]:=
  Module[
    {
      pot=potentialGenerator[{a, s}],
      wfs,
      wfs2D,
      coeffs,
      expand
      },
    If[pot===$Failed,
      $Failed,
      wfs=
        scfWavefunction[
          scf1DDVR,
          scfGrid,
          pot,
          states
          ];
      wfs2D=
        scf2DDVR[
          "Wavefunctions",
          "Points"->{basisSize, basisSize},
          "PotentialOptimize"->False,
          "PotentialFunction"->pot,
          "NumberOfWavefunctions"->Length@states,
          "PreadjustHamiltonian"->False,
          "ValidateHamiltonian"->False
          ];
      <|
        "SCFWavefunctions"->wfs, 
        "DVRWavefunctions"->wfs2D
        |>
      ]
    ]


(* ::Subsubsection::Closed:: *)
(*Overlaps*)



(* ::Subsubsubsection::Closed:: *)
(*smoothOutCoeffs*)



smoothOutCoeffs//Clear
smoothOutCoeffs[coeffGrid_, dir:First|Last, cutoff:_?NumericQ:0]:=
  Module[
    {
      aSlices,
      g,
      df,
      twoDs,
      signFlips,
      rephasable,
      rephaseVector,
      startPhase,
      rephased,
      gind1 = Replace[dir, {First->1, Last->2}],
      gind2 = Replace[dir, {First->2, Last->1}]
      },
    aSlices = KeySort@GroupBy[coeffGrid, (#[[gind1]]&)->(#[[{gind2, 3}]]&)];
    startPhase = 
      With[{l=KeySort@GroupBy[coeffGrid, (#[[2]]&)->(#[[3]]&)]},
        Sign@Mean@l[[Floor[Length[l]/2]]]
        ];
    twoDs = 
      With[{gg=SortBy[#, First]},
        (*Transpose[{
  	      gg[[All, 1]],*)
          NDSolve`FiniteDifferenceDerivative[
           Derivative[2], 
           Sequence@@Transpose[gg]
            ](*
          }]*)
       ]&/@aSlices;
    signFlips = 
      MovingMap[Times@@Sign[#]&, #[[All, 2]], 1]&/@aSlices;
    rephasable=
      MapThread[
        (* 1 at the already fine places and -1 where not *)
        1+-2*UnitStep[-#]*UnitStep[Abs[Most[#2]]-cutoff, 1]&,
        {
          signFlips,
          twoDs
          }
        ];
     rephased=
       MapThread[
         With[{shiftInside=Floor[Length[#]/4]},
           Transpose[{
             #[[All, 1]],
             Prepend[RotateLeft[Rest[#], shiftInside], #[[1]]]&[
               rephaseThingies[
                 (* to get away from the broken edges... *)
                 RotateRight[#2, shiftInside],
                 (* get the base phase *) 
                 Replace[
                   Replace[Sign[#[[shiftInside, 2]]], 0->1]*
                     Replace[startPhase, 0->1], 
                   0->1
                   ], 
                 0]
                ]*#[[All, 2]]
             }]
           ]&,
         {
           aSlices ,
           rephasable
           }
         ];
    Join@@
      KeyValueMap[
        Transpose[
          {
            ConstantArray[#, Length@#2], 
            #2[[All, 1]], 
            #2[[All, 2]]
            }[[{gind1, gind2, 3}]]
          ]&,
        rephased
        ]
      ]


needsSmoothingTest[coeffGrid_, dir_]:=
  Module[{gridChunks, signFlips},
    gridChunks = GroupBy[coeffGrid, Replace[dir, {First->Last, Last->First}]->(#[[3]]&)];
    signFlips = Total@Abs@Flatten[Values[Differences@*Sign/@gridChunks]];
    Greater@@{signFlips/2., Length[coeffGrid]/10}
    ]


smoothOutCoeffs[coeffGrid_, dir:Automatic:Automatic, cutoff:_?NumericQ:0]:=
  If[needsSmoothingTest[coeffGrid, Last],
    Fold[
      smoothOutCoeffs[#, #2[[1]], cutoff+#2[[2]]]&,
      coeffGrid, 
      Thread@{
        Flatten@ConstantArray[{Last, First}, 6],
        (*1**)0Riffle[Range[0, 5], Range[0, 5]]
        }
      ],
    coeffGrid
    ]


(* ::Subsubsubsection::Closed:: *)
(*getSCFOverlapMatrix*)



(* ::Subsubsubsubsection::Closed:: *)
(*Old*)



(*getSCFOverlapMatrix[scfWavefunctions_, dvrWavefunctions_, states_, scalings_]:=
	Module[
		{
			fleng,
			overlapStates=states,
			scalingThings=scalings,
			blerp,
			baseWfnsSCF,
			baseWfnsDVR,
			expansionCoeffs,
			blerpDVR,
			coeffs,
			overlaps,
			goodPlace,
			goodPos,
			goodPairs,
			goodSparseOneQuantum
			},
		If[Length@overlapStates!=Length@scalingThings, Throw@"I'm sad"];
		fleng=Length[scfWavefunctions];
		blerp=Select[scfWavefunctions, #=!=$Failed&];
		blerpDVR=Select[dvrWavefunctions, #=!=$Failed&];
		baseWfnsSCF=
			Table[Join@@Map[#[[{n}]]&, blerp], {n, overlapStates}];
		baseWfnsDVR=
			Table[Join@@Map[#[[{n}]]&, blerpDVR], {n, overlapStates}];
		coeffs=
			Apply[
				Join,
				scalingThings*
				Table[
					Transpose@
						Table[
							Developer`ToPackedArray[Diagonal[dvrWfs@"Overlaps"[scfWfs]]],
							{scfWfs, baseWfnsSCF}
							],
					{dvrWfs, baseWfnsDVR}
					]
				];
		overlaps=coeffs.Transpose[coeffs];
		{
			overlaps,
			goodPlace=Pick[Range[fleng], #=!=$Failed&/@scfWavefunctions];
			goodPos=Join@@Map[#+goodPlace&, Range[0, Length[overlapStates]-1]*fleng];
			goodPairs=Developer`ToPackedArray@Tuples[goodPos, 2];
			SparseArray[goodPairs\[Rule]Flatten@overlaps, Length[overlapStates]*fleng*{1,1} , 0.]
			}
		]*)


(* ::Subsubsubsubsection::Closed:: *)
(*New*)



getSCFOverlapMatrix//Clear
getSCFOverlapMatrix[
  scfWavefunctions_, dvrWavefunctions_, 
  states_, 
  scalings_, 
  grid_, extrapGrid_,
  symmetries_,
  coefficientProcessing_:None
  ]:=
  Module[
    {
      nstates, fleng, pickSpec, pickComp,
      gg, blerp, blerpDVR, 
      baseWfnsSCF, baseWfnsDVR, 
      coeffs, coeffLists,
      baseGrid, extrapCoeffs, 
      coeffInterps, newCoeffs,
      fuckTheseFuckingPointsFuckThisIDontWantToDoIt,
      coeffList
      },
    nstates = Length@states;
    pickSpec = Pick[Range[Length[scfWavefunctions]], #=!=$Failed&/@scfWavefunctions];
    pickComp = Pick[Range[Length[scfWavefunctions]], #===$Failed&/@scfWavefunctions];
    fleng = Length[pickSpec];
    debugPrint["Loading base coefficients"];
   blerp=scfWavefunctions[[pickSpec]];
    blerpDVR=dvrWavefunctions[[pickSpec]];
    gg = Join@@ConstantArray[grid[[pickSpec]], nstates];
    baseWfnsSCF=
      Table[Join@@Map[#[[{n}]]&, blerp], {n, states}];
    baseWfnsDVR=
      Table[Join@@Map[#[[{n}]]&, blerpDVR], {n, states}];
    coeffs=
      Apply[
        Join,
        Table[
          Transpose@
            Table[
              Developer`ToPackedArray[Diagonal[dvrWfs@"Overlaps"[scfWfs]]],
              {scfWfs, baseWfnsSCF}
              ],
          {dvrWfs, baseWfnsDVR}
          ]
        ];
    coeffLists = Join[gg, coeffs[[All, {#}]], 2]&/@Range[nstates];
    debugPrint["Extrapolating coefficients"];
    coeffInterps = 
      Table[
        coeffList = coeffLists[[j]];
        debugPrint["Loading base function data"];
        baseGrid=
          Join[
            Join[grid[[pickComp]], ConstantArray[10^9, {Length@pickComp, 1}], 2],
            coeffList[[1+(i-1)*fleng ;; i*fleng]]
            ];
        (*With[{u=Unique[coefficientsGrid]}, u=baseGrid;dumpSymbol[u]];*)
        debugPrint["Extrapolating off grid"];
        extrapCoeffs=
          extrapolatedFunction[
              baseGrid,
              {2, 2},
              {#^Range[1]&, #^Range[1]&},
              "Both",
              symmetries[[i]],
              DefaultValue[0]
              ];
        (*dumpValue[
				  ToExpression["extrapolatedCoeffs$"<>ToString@i<>ToString@j],
				  extrapCoeffs,
				  False
				  ];*)
        extrapCoeffs =
          If[coefficientProcessing===None,
            smoothOutCoeffs[extrapCoeffs],
            Replace[Quiet@coefficientProcessing[[i, j]],
              {
                p_Part:>smoothOutCoeffs
                }
              ][extrapCoeffs]
            ]; (* a total hack... *)
        dumpValue[
          ToExpression["extrapolatedCoeffs$"<>ToString@i<>ToString@j],
          extrapCoeffs,
          False
          ];
        debugPrint["Constructing interpolation off grid"];
        fuckTheseFuckingPointsFuckThisIDontWantToDoIt=
          DeleteDuplicatesBy[
            Join[
              extrapCoeffs[[All, ;;2]], 
              List/@Clip[extrapCoeffs[[All, 3]]],
              2
              ],
            Round[#[[;;2]], .01]&
            ];
      (*dumpSymbol[fuckTheseFuckingPointsFuckThisIDontWantToDoIt];*)
        fuckTheseFuckingPointsFuckThisIDontWantToDoIt//Interpolation,
        {j, Length@coeffLists},
        {i, nstates}
        ];
    coeffs = 
      Normalize/@Transpose[
        Table[
          Apply[
            Join,
            With[{interp=#},
              interp@@Transpose[extrapGrid]
              ]&/@interpList
            ],
          {interpList, coeffInterps}
          ]
        ];
    coeffs.Transpose[coeffs]
    ]


(* ::Subsubsection::Closed:: *)
(*Wavefunctions*)



(* ::Subsubsubsection::Closed:: *)
(*Kinetic Energy*)



coupledKineticEnergy//Clear;
coupledKineticEnergy[dvr_, grid_, overlapMat_, i___]:=
  Module[
    {
      lens=Length[{i}],
      woop,
      waap=dvr["KineticEnergy", "Points"->Dimensions[grid]],
      klap
      },
    woop=overlapMat;
    (*Echo[{Dimensions[grid], Dimensions[waap], Dimensions[woop]}];*)
    If[Length[woop]=!=lens*Length[waap],
      Throw[
        "Overlap matrix misdimensioned, `` overlaps, `` functions, `` points"~TemplateApply~{
          Dimensions[woop],
          lens*Dimensions[waap],
          Dimensions[grid]
        }
        ],
      klap=
        KroneckerProduct[ConstantArray[1, {lens, lens}], waap];
      SparseArray[woop*klap] (* this _must_ be a SparseArray to be manageable later *)
      ]
    ];


(* ::Subsubsubsection::Closed:: *)
(*Potential Energy*)



(* ::Subsubsubsubsection::Closed:: *)
(*getPot*)



getPot[wfns_, i_]:=
  Join[
    Keys[wfns],
    Developer`ToPackedArray@Map[
      If[#===$Failed, {10.^9}, #["Energies"][[{i}]]]&,
      Values@wfns
      ],
    2
    ];


(* ::Subsubsubsubsection::Closed:: *)
(*averagedPot*)



averagedPot[wnfs_, i_]:=
  Developer`ToPackedArray@Map[
    If[#===$Failed, {10.^9}, #["Energies"][[{i}]]]&,
    Values@wnfs
    ]


(* ::Subsubsubsubsection::Closed:: *)
(*extrapolatedPotential*)



extrapolatedPotential[grid_, wfns_, i_]:=
  Module[
    {
      pot,
      extrap,
      interp
      },
    debugPrint["Extracting potential"];
    pot = getPot[wfns, i];
    debugPrint["Extrapolating potential"];
    extrap =
      extrapolatedFunction[
          pot,
            {0, 10^9.-1},
            {Scaled[1], Scaled[.2]},
            {#^Range[6]&, #^Range[1]&}
            ];
    dumpValue[
      ToExpression["extrapPot$"<>ToString@i],
      extrap,
      False
      ];
    interp=
        Interpolation[
          extrap,
          {
            "ExtrapolationHandler"->{
              (10.^9&),
              "WarningMessage"->False
              }
            }
          ];
    interp@@Transpose[grid]
    ]


(* ::Subsubsubsubsection::Closed:: *)
(*coupledPot*)



coupledPot[grid_, wfns_, i___]:=
  SparseArray[
    Band[{1, 1}]->
      Developer`ToPackedArray@
        Apply[Join, 
          Map[
            extrapolatedPotential[grid, wfns, #]&, 
            {i}
            ]
          ]
    ];


(* ::Subsubsubsection::Closed:: *)
(*Grid*)



coupledGrid[grid_, i__]:=
  With[{g=grid@"Grid", l=Length[{i}]},
    CoordinateGridObject@
      Apply[
        Join,
        With[{m=ConstantArray[{2*#*Min[g], 0}, Dimensions[g][[;;2]]]},
          g-m
          ]&/@Range[0, l-1]
        ]
    ]


(* ::Subsubsubsection::Closed:: *)
(*getWavefunctions*)
 


getWavefunctions[wfns_, dvr_, overlaps_, grid_, states___]:=
  WavefunctionsObject[
    "Diagonalize",
    debugPrint["Making kinetic energy"];
    coupledKineticEnergy[dvr, grid, overlaps, states],
    debugPrint["Making potential energy"];
    coupledPot[grid["Points"], wfns, states],
    debugPrint["Making grid"];
    coupledGrid[grid, states],
    debugPrint["Diagonalizing"];
    "NumberOfWavefunctions"->100,
    "ArnoldiIterations"->10000,
    "PruningEnergy"->Scaled[.9],
    "ValidateHamiltonian"->False
    ];


(* ::Subsubsubsection::Closed:: *)
(*pullProjections*)



pullProjections[wfns_, grid_, states_]:=
  With[{g2=grid, g=Min[grid["Points"]], len = Dimensions[grid][[1]], couplings=states},
    MapThread[
      Function[
        WavefunctionsObject[
          {
            #["Energies"],
            GridFunctionObject[
              g2,
              #@"Values"
              ]&/@#["Wavefunctions"]
            },
          g2
          ]&@wfns[[All, #;;#2]]
        ],
      {
        1+Range[0, Length[couplings]-1]*len,
        Range[Length@couplings]*len
        }
      ]
    ]


(* ::Subsubsection::Closed:: *)
(*Spectra*)



(* ::Subsubsubsection::Closed:: *)
(*rebuildInterpolation*)



rebuildInterpolation[interp_]:=
  Interpolation[
    Join[
      Flatten[interp["Grid"], 3],
      List/@Flatten[interp["ValuesOnGrid"], 3],
      2
      ],
    {
      "ExtrapolationHandler"->{
          0.&,
          "WarningMessage"->False
          }
      }
    ]


(* ::Subsubsubsection::Closed:: *)
(*interpolatedDipoleSurface*)



interpolatedDipoleSurface[interp_, {a_, s_}]:=
  With[{R1=1/Sqrt[2.](a+s), R2=1/Sqrt[2.](s-a)},
    interp[Sequence@@Transpose[#], R1, R2]&
    ]


(* ::Subsubsubsection::Closed:: *)
(*getDipoleVecs*)



getDipoleVecs[wfns_, gps_, interp_]:=
  MapIndexed[
    With[{fg=gps},
      If[#=!=$Failed,
        Developer`ToPackedArray[interpolatedDipoleSurface[interp, #2[[1, 1]]]@fg],
        $Failed
        ]&
      ],
    (* This is just here for the keys and the $Failed *)
    wfns
    ]


(* ::Subsubsubsection::Closed:: *)
(*getTransitionMoments*)



getTransitionMoments[wfns_, dipoles_]:=
  MapThread[
    If[#=!=$Failed,
      #@"TransitionMoments"[
          {
            #2, 
            ConstantArray[0., Length[#2]], 
            ConstantArray[0., Length[#2]]
            },
          {1, 1;;Length@#["Wavefunctions"]}
          ],
      $Failed
      ]&,
    {
      wfns,
      dipoles
      }
    ]


(* ::Subsubsubsection::Closed:: *)
(*getTransitionWavefunctions*)



getTransitionWavefunctions[projs_, gsData_]:=
  Map[
    WavefunctionsObject[
      {
        Prepend[#["Energies"], gsData[[1]]], 
        Prepend[#["Wavefunctions"], gsData[[2]]]
        }, 
      gsData[[2]]["Grid"]
      ]&,
    projs
    ]


(* ::Subsubsubsection::Closed:: *)
(*getIntensities*)



getIntensities[wfns_, states_, gridTms_, problemStates:{__Integer}:{4, 5}]:=
  Module[
    {
      baseTmoms,
      tmomLists,
      tmGrid,
      tmInterps,
      tms,
      wfGrid
      },
    tmGrid = gridTms["Grid"];
    tmInterps =
      Transpose@Table[
        lInter[ (* should definitely check my grid though... *)
          If[i==1, (* it's crazy how much of a hack this is but I am currently in get-something-out mode... *)
            dumpValue[
              ToExpression["smoothGridTMs$"<>ToString@i<>ToString[state]],
              If[MemberQ[problemStates, state], correctRowFlips@#, #],
              False
            ],
          #
            ]&@Join[tmGrid, gridTms[["Values", state, All, {i}]], 2],
          {
            "ExtrapolationHandler"->{0&, "WarningMessage"->False}
            }
          ],
        {i, 3},
        {state, states}
        ];
    wfGrid = Flatten[Normal@wfns[[1]]["Grid"], 1]; (* for some reason "Points" stopped working? *)
    If[!ListQ@wfGrid, 
      Throw[StringForm["Head is not List for wfns[\"Grid\"]"]];
      ];
    (*dumpSymbol[wfGrid];
		dumpSymbol[tmInterps];*)
    tms = Transpose[Through[#@@Transpose[wfGrid]]]&/@tmInterps;
    (*dumpSymbol[tms];*)
    baseTmoms=
      Table[
          wf@"TransitionMoments"[
              Transpose[tm],
              {1, If[MemberQ[states, 1], 1, 2];;Length[wf]}
              ],
          {wf, wfns},
          {tm, tms}
          ];
    dumpValue[
      ToExpression["baseTmoms$"<>Map[ToString, states]],
      baseTmoms,
      False
      ];
    (*
		Each wavefunction operates over a different state.
		*)
    tmomLists = 
      MapIndexed[Total@#[[All(*#2[[1]]*), All, 1]]&, baseTmoms];
    Total[tmomLists]^2
    ]


(* ::Subsubsubsection::Closed:: *)
(*getFreqs*)



getFreqs[wfns_, gsData_]:=
  wfns["Energies"]-gsData[[1]]


(* ::Subsubsubsection::Closed:: *)
(*buildSpectra*)



buildSpectra[freqs_, ints_]:=
  Module[
    {
      transInts,
      filen,
      fs,
      is
      },
    filen = Min[Length/@{freqs, ints}];
    fs = freqs[[;;filen]];
    is = ints[[;;filen]];
    transInts=
      MapThread[
        With[{mlen=Min[Length/@{#, #2}]},
          #[[;;mlen]]*#2[[;;mlen]]
          ]&,
        {fs, is}
        ];
    transInts=transInts/Max[transInts];
    MapThread[
      ChemSpectrum@Transpose[{#, #2}]&,
      {
        fs,
        transInts
        }
      ]
    ]


End[];


EndPackage[];



